##
# printing graphs with kk layout
##
age = 'Old'
G = read.graph(file=paste0(grdir, age,"_", "D2",
                           "_igraph.ml"), format="graphml")
G_Grouped = G
E(G_Grouped)$weight = 0.5

V(G)$group = igraph::vertex_attr(G, "celltype", index = V(G))
groups = unique(igraph::vertex_attr(G, "celltype", index = V(G)))

E(G)$color = igraph::edge_attr(G,"ecolor", index=E(G))

for (i in groups){
  GroupV = which(V(G)$group == i)
  G_Grouped = add_edges(G_Grouped,combn(GroupV,2), 
                        attr=list(weight=1))
}
# layout_with_dh exploses time !!!
# gem exploses time !!
# graphopt mixes and superposes
# drl superposes a lot
# lgl is for large connected graphs


LO = layout_with_mds(G_Grouped)
plot(G,vertex.size=3, mark.border=NA,
     edge.border=NA,  vertex.border="white",
     vertex.label =NA, edge.arrow.size=0.005,
     edge.arrow.width=0.00001, layout=LO) + title(main = "mds")

#  kk (larger the weight, closer the nodes)
G_Grouped = G
E(G_Grouped)$weight = 30
V(G)$group = igraph::vertex_attr(G, "celltype", index = V(G))
groups = unique(igraph::vertex_attr(G, "celltype", index = V(G)))
E(G)$color = igraph::edge_attr(G,"ecolor", index=E(G))
for (i in groups){
  GroupV = which(V(G)$group == i)
  G_Grouped = add_edges(G_Grouped,combn(GroupV,2), 
                        attr=list(weight=50))
}
LO = layout_with_kk(G_Grouped, maxiter=300)
plot(G,vertex.size=2, mark.border=NA,
     edge.border=NA,  vertex.border="white",
     vertex.label =NA, edge.arrow.size=0.005,
     edge.arrow.width=0.00001, layout=LO) + title(main="kk")

# fr :  larger values longer edges fr (is contrary to kk)
G_Grouped = G
E(G_Grouped)$weight = 25
V(G)$group = igraph::vertex_attr(G, "celltype", index = V(G))
groups = unique(igraph::vertex_attr(G, "celltype", index = V(G)))
E(G)$color = igraph::edge_attr(G,"ecolor", index=E(G))
for (i in groups){
  GroupV = which(V(G)$group == i)
  G_Grouped = add_edges(G_Grouped,combn(GroupV,2), 
                        attr=list(weight=22))
}
LO = layout_with_fr(G_Grouped, niter=300)
plot(G,vertex.size=2, mark.border=NA,
     edge.border=NA,  vertex.border="white",
     vertex.label =NA, edge.arrow.size=0.005,
     edge.arrow.width=0.00001, edge_alpha = 0.5, layout=LO) + title(main = "fr")



###  clustering for other scenarios: 
ebc <- cluster_edge_betweenness(G)
communities$`Edge betweenness` <- ebc
####


############################   NEW TITLE
# DEALING WITH WEAKLY CONNECTED NETS: AGGREGATE INFORMATION:
# #  ============ minimal test
# mini = matrix(c(100,200,10,50), 2,2 ) 
# rownames(mini) = c('A','B')
# colnames(mini) = c('A','B')
# mat
# #    A  B
# # A 100 10
# # ...
# circos.clear()
# chordDiagram(mini, directional = 1, 
#              link.arr.width = 0.05,
#              link.arr.length = 0.08,
#              direction.type = "arrows",
#              link.arr.col =  "whitesmoke",           
#              self.link = 1,
#              annotationTrack = c("name", "grid"," axis")
# ) + title("my smaaaall test")
# circos.clear()


# =================================================
# try to build a matrix counting the connections:
# universal colors used for cell types
# ok for color blindness!  hex codes: https://rdrr.io/cran/ggthemes/man/colorblind.html

library(circlize)
#Gege = read.graph(file=paste0(grdir, "Old","_","D2",
 #                      "_igraph.ml"), format="graphml")

givememystuff <- function(G){
  # produces 4 matrices, for example counts:
  #         FAPs Neutro sCs ECs  M1  M2
  # FAPs    202    125 198 178 152 149
  # Neutro   57     44  67  81  36  51
  # sCs     137     71 149 112  73  79
  # ...
  tabedges = igraph::as_data_frame(G,"edges")
  tabvertx = igraph::as_data_frame(G, "vertices")
  groups = unique(igraph::vertex_attr(G, "celltype", index = V(G)))
  # mat : a matrix that counts connections among given cell types 
  mat = matrix(0, length(groups),length(groups) )  # counts matrix
  rownames(mat) = groups
  colnames(mat) = groups
  w_mat = mat    #  a matrix that sums weights of those connections
  for (i in 1:dim(tabedges)[1]){
    typeorig <- unlist(str_split(tabedges[i,]$origtype, "_"))[2]
    dest <- tabedges[i,]$to
    typedest <- tabvertx[dest,]$celltype
    mat[typeorig,typedest] = mat[typeorig,typedest] + 1
    w_mat[typeorig,typedest] = w_mat[typeorig,typedest] + tabedges[i,]$weight
  }
  colormatrix =  matrix('', length(groups),length(groups) )
  rownames(colormatrix) = groups
  colnames(colormatrix) = groups
  for (i in 1:length(groups)){
    colormatrix[i,] <- rep(cellcolors[[groups[i]]], length(groups))
  }
  r_mat = w_mat/mat   # ratio matrix, weight/number
  return(list("number"=mat, "cummul_w"=w_mat, "ratio"=r_mat, "colorsmat"=colormatrix))
}

youpi = givememystuff(Gege)

# idea : make ratio button, by default circos only with RATIO, offer nb and cummul weight
cellcolors = list(
  "ECs"="#0072B2",
  "FAPs"="#F0E442",
  "M1" = "#D55E00",
  "M2" =  "#CC79A7",
  "Neutro" =  "#009E73",
  "sCs" = "#56B4E9" 
)
circos.clear()
#  add titles as thing goes plotted in apllication because here it does not work 
chordDiagram(youpi[["number"]], directional = 1, 
             grid.col = unlist(cellcolors),
             col = youpi[["colorsmat"]],
             direction.type = c("diffHeight", "arrows"),
             link.arr.type = "big.arrow",
             self.link = 1,
             annotationTrack = c("name", "grid"," axis")) 
#+ title("Number of connections")
circos.clear()

chordDiagram(youpi[["ratio"]], directional = 1, 
             grid.col = unlist(cellcolors),
             col = youpi[["colorsmat"]],
             direction.type = c("diffHeight", "arrows"),
             link.arr.type = "big.arrow",
             self.link = 1,
             annotationTrack = c("name", "grid"," axis")) 
circos.clear()
chordDiagram( youpi[["cummul_w"]], directional = 1, 
             grid.col = unlist(cellcolors),
             col = youpi[["colorsmat"]],
             direction.type = c("diffHeight", "arrows"),
             link.arr.type = "big.arrow",
             self.link = 1,
             annotationTrack = c("name", "grid"," axis")) 
circos.clear()

# circos.clear()
# chordDiagram(mat, directional = 1, 
#              grid.col = unlist(cellcolors),
#              col = colormatrix,
#              direction.type = c("diffHeight", "arrows"),
#              link.arr.type = "big.arrow",
#              self.link = 1,
#              annotationTrack = c( "grid"," axis"),
#              annotationTrackHeight = mm_h(5))
# for(si in get.all.sector.index()){
#   xlim = get.cell.meta.data("xlim", sector.index = si, track.index = 1)
#   ylim = get.cell.meta.data("ylim", sector.index = si, track.index = 1)
#   circos.text(mean(xlim),mean(ylim),si, sector.index = si,
#               track.index = 1, facing="bending.inside", niceFacing = T, col = "white")
# }






